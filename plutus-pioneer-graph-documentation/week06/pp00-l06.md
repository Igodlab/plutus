#### id [[pp00-l06]]
# Plutus Pioneer-Lecture6
---
This is the Plutus Pioneer first ever course. Thaught by [Dr. Lars BrÃ¼njes](https://github.com/brunjlar). Find it on [Youtube](https://www.youtube.com/watch?v=wY7R-PJn66g&t=4865s) and [Github](https://github.com/input-output-hk/plutus-pioneer-program/tree/main/code/Week06).
---

In this lecture we explore the concept of Oracles in Cardano. 

- Fully fledged Dapp (run on mockchain)
- Contains all pieces for real apps
- Example: Oracles
  - "Service"/Way to get real world data on blockchain
  - Make it usable in smart contracts
  - Like: Weather data, election results, stock exchanges, randomness, ...
  - E.g. betting on result of a sport game
- Here: One feed of data
  - Exchange rate of USD-to-Dollar
  - Risk: Need to rely on the source for this data
    - May fail to provide data
    - May provide wrong data
    - ...
  - Ways to migitate:
    - Make provider put down collateral: If provider fails to provide data, it looses this collateral
    - Or: Combine multiple oracles
    - Only accept if all agree, or take average, ...
  - For example: One provider which we trust


## Idea of Oracle

- Use UTxO: Oracle value sits at script address of Oracle
- Problem
  - Validation only happens on consumption
  - I.e. cannot prevent anybody from providing arbitrary output at same Oracle script address
  - => Need a way to distinguish true UTxO from others
  - Put NFT value on true Oracle UTxO

- How can it be used?
  - Until now: Knew all ways to use contract upfront
  - Here: Different, dont know how Oracle will be used
  - So an open API must be provided
  - I.e. must be usable by smart contracts which do not exist at the time when the Oracle is created

## Swap Contract: ADA to USD

- Incentive for Oracle to create data:
  - Puts fee whenever data is used (e.g. 1 ADA)
- Example:
  - Swap 100 ADA to USD (Seller)
  - Buyer pays fee and gets ADA

- Transaction
  - Spents Oracle UTxO (with NFT)
  - Validator `use` needs to check
    - NFT present in UTxO
    - Exists output at same Oracle address,
    - also containing NFT and same Oracle value (`Datum`)
    - Fee must be paied to Oracle
  - Validator `swap` needs to check
    - Consume UTxO of ADA-Seller with ADA
    - Buyer UTxO for providing USD and paying fees
    - Transaction output to seller: USDs
    - Transaction output to buyer: ADA

- Note: `swap` just one example, there will be much more use cases of the Oracle

- Also: Need to be a way for price of ADA-to-USD to be updated
  - Other Oracles, like result of sports match, are single events in history
    - So not all Oracles need update functionality
  - But here: Provider must be able to change value
  - Transaction must
    - consume UTxO and provide new one which provides updated UTxO
    - Plus pay fee to owner
    - Must be signed by Oracle provider

## Contracts this week

#### Core.hs [[pp00-l06-Core-1]]
#### Swap.hs [[pp0-l06-Swap-1]]
#### Funds.hs [[pp0-l06-Funds-1]]
#### PAB.hs [[pp0-l06-PAB-1]]
#### Test.hs [[pp0-l06-Test-1]]

    - Note: No further checks, so operator can pay fees to himself
  - Checks for use
    - Prohibit datum to change
    - Ensure fees have been paid
      - Check that own outputs are greater or equals to
      - own inputs, plus fees
      - By doing "greater or equals": User of Oracle can pay a tip

- Off-chain code
  - Only start and update oracle
  - Not usage: This is not responsibility of Oracle provider
    - I.e. on-chain code with Redeemer `Use` is not reflected in off-chain code

  - Start:
    - Params for Oracle, `OracleParams`
    - No initial value, since creating NFT takes some slots
      - I.e. exchange rate may be outdated already
    - Mint NFT (only thing done in start)
      - Use `forgeContract` from `Currency` module (in `plutus-use-cases`)
        ```haskell
        forgeContract :: PubKeyHash -> [(TokenName, Integer)] -> Contract w s e OneShotCurrency
        ```
      - Note: Requires to map the `Contract` monad's error messages to `Text` with `mapError`
  - Update:
    - Must handle case where no UTxO exist yet
      - Done by using `findOracle`
      - Checks if at script address exists an UTxO with NFT
      - Returns a `Maybe` to signal if not present (Oracle just started)
    - If no UTxO found
      - Create UTxO at address with first exchange rate
      - `mustPayToTheScript` , with NFT and `Datum`
    - If UTxO exists
      - Existing UTxO must be spent, `mustSpendScriptOutput`
      - Requires lookups
        - `unspentOutputs` to find the UTxO ref which needs to be spent
        - Must provide script instances for input side (`scriptInstanceLookups`) and output side (`otherScript`)
      - Note: Balancing the transaction, will lead to pay fees from script to operator.
        - Since in input NFT with value, but on output only NFT
        - So inbalance of the payed fees (from Oracle users)
        - Balancing algorithm defaults to paying fees to own wallet
      - Also creates input which pays for transation fees

- Run Oracle function
  - Has endpoint `update`
  - Starts Oracle (i.e. mints NFTs)
  - And writes oracle value
  - Use `tell` to communiate the just created Oracle to the outside world
