%% Extended UTXO Specification

\newcommand\version{-1}

\title{Formal Specification of the Extended UTxO Model\\--- \\
  \red{\textsf{PRELIMINARY DRAFT!}}}

\pagestyle{plain}
\date{26th April 2019}

\documentclass[a4paper]{article}

\usepackage{blindtext, graphicx}
\usepackage{url}

% *** MATHS PACKAGES ***
%
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}

% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
\usepackage{float}  %% Try to improve placement of figures.  Doesn't work well with subcaption package.
\usepackage{subcaption}
\usepackage{caption}

% correct bad hyphenation here
\hyphenation{}

\usepackage{subfiles}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}


%%% General Misc. Definitions

%% A version of ^{\prime} for use in text mode
\makeatletter
\DeclareTextCommand{\textprime}{\encodingdefault}{%
  \mbox{$\m@th'\kern-\scriptspace$}% 
}
\makeatother

\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\redfootnote}[1]{\red{\footnote{\red{#1}}}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\bluefootnote}[1]{\blue{\footnote{\blue{#1}}}}

\renewcommand{\i}{\textit}  % Just to speed up typing: replace these in the final version
\renewcommand{\t}{\texttt}  % Just to speed up typing: replace these in the final version
\newcommand{\s}{\textsf}  % Just to speed up typing: replace these in the final version

\theoremstyle{definition}  %% This applies to all following \newtheorem items
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\newenvironment{arraydefs}[1]{\setlength{\arraycolsep}{0pt}\begin{array}{#1}}{\end{array}}
%
% This is just the array environment with the column separation set to 0.
% This is to enable us to get things like
%
%%   X = (field1: type1,
%         field2: type2,
%         ...
%
% without a space after the ')'. Unfortunately you have to manually insert a space
% at the end of the X so you don't get X=
% There's presumably a better way to do this.
%
% You can also use something like
%
%    \begin{tabular}{r@{ }l@{}l} ...
%
% but the spacing is arguably worse.


\newcommand\rfskip{7pt}
\newenvironment{ruledfigure}[1]{\begin{figure}[#1]\hrule\vspace{\rfskip}}{\vspace{\rfskip}\hrule\end{figure}}

% Macros for xutxo things.
\newcommand{\mi}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\txid}{\mi{txid}}
\newcommand{\inputs}{\mi{inputs}}
\newcommand{\outputs}{\mi{outputs}}
\newcommand{\forge}{\mi{forge}}
\newcommand{\fee}{\mi{fee}}
\newcommand{\addr}{\mi{addr}}
\newcommand{\val}{\mi{value}}  %% \value is already defined
\newcommand{\vals}{\mi{vals}}

\newcommand{\validator}{\mi{validator}}
\newcommand{\redeemer}{\mi{redeemer}}
\newcommand{\datascript}{\mi{datascript}}
\newcommand{\outputref}{\mi{outputRef}}
\newcommand{\txin}{\mi{in}}
\newcommand{\txout}{\mi{out}}
\newcommand{\id}{\mi{id}}
\newcommand{\getvalue}{\msf{getvalue}}

\newcommand{\msf}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\slotnum}{\msf{SlotNumber}}
\newcommand{\spent}{\msf{spentOutputs}}
\newcommand{\unspent}{\msf{unspentOutputs}}
\newcommand{\xutxotx}{\msf{XUtxoTx}}



%% ------------- Start of document ------------- %%

\begin{document}
\maketitle

\section{Introduction: The Extended UTXO Model}
\label{sec:intro}
The Cardano blockchain uses a variant of the \textit{Unspent
  Transaction Output} (UTXO) model used by Bitcoin.  Transactions
consume \textit{unspent outputs} (UTXOs) from previous transactions
and produce new outputs which can be used as inputs to later
transactions.  Unspent outputs are the liquid funds on the
blockchain. Users do not have individual accounts, but rather have a
software \textit{wallet} on a smartphone or PC which manages UTXOs on
the blockchain and can initiate transactions involving UTXOs owned by
the user.  Every core node on the blockchain maintains a record of all
of the currently unspent outputs, the \textit{UTXO set}; when outputs
are spent, they are removed from the UTXO set.

This document proposes two extensions to the basic UTXO model, including
formal mathematical descriptions of both:
\begin{itemize}
\item A version including enhanced scripting features, allowing the
  implementation of complex smart contracts (Section~\ref{sec:xutxo}).
\item A further extension including support for multiple (perhaps user-defined)
  currencies (Section~\ref{sec:multicurrency}).
\end{itemize}

\noindent The second of these subsumes the first, but (for now, anyway) we give
separate descriptions of the two versions in order to demonstrate the
increase in expressivity provided by each extension.

\section{The Basic UTXO model: Outputs and scripts}
\label{sec:utxo-intro}

There is no well-defined notion of ownership for UTXOs.  In many
transactions an output will accrue to a single user who is then
entitled to spend it at a later date.  However, in general the notion
of ownership is more complex: an output of a transaction might require
the cooperation of several users before it could be spent, or it might
not be spendable until some other condition has been met (for example
a certain period of time may have to pass).  At the extremes, an
output could be spendable by anyone, or by no-one.

In order to deal with this complexity, an output can be locked by a
\textit{script}, requiring another script to unlock it.  In the
Cardano setting, scripts are Plutus Core
programs~\cite{Plutus-Core-spec} (equivalently, expressions).  In the
basic model, each input to a transaction comes with a \i{validator}
script which checks that the transaction is allowed to spend the
output. To prove that it is allowed to spend an output, the
transaction supplies another script, called the \i{redeemer}\footnote{
  The validator plays a role similar to that of BitCoin's
  \texttt{scriptPubKey} and the redeemer to \texttt{scriptSig}.}.

In a process known as \i{validation}, the validator is run with the
redeemer as input, and if it terminates without an error arising then
the output can be spent.  Before a transaction can proceed, all inputs
must be successfully validated: if one or more inputs fails to validate
then the transaction is rejected (\blue{is this true?}).

A simple example of this is a \i{pay-to-pubkey} script, where the
redeemer consists of a signature for the current transaction produced
using a private key belonging to the owner of the output.  The
validator (provided by the owner of the output) would check the
signature using a known public key: if the public key corresponds to
the private key then validation succeeds, otherwise it fails.  Thus
the output can only be spent by the owner of the relevant private key.

\section{The Extended UTXO Model}
\label{sec:xutxo}
The papers~\cite{Zahnentferner18-UTxO}
and~\cite{Zahnentferner18-Chimeric} contain a mathematical description
of the UTXO model currently used in Cardano, which is basically that
described in Section~\ref{sec:utxo-intro}.  In this document we specify
some extensions which increase the expressivity of the existing UTXO
model.  We refer to the extended version as the \textit{Extended UTXO}
(XUTXO) model.  


The XUTXO model introduces the following new features:

\begin{itemize}
\item Every transaction has a \textit{validity interval}, consisting
  of two slot numbers: a core node will only process the transaction
  if the current slot number lies within the transaction's validity
  interval.
\item We introduce a new type of script called a \i{data script},
  and each unspent output has a (possibly empty) data script
  associated with it.  The introduction of the data script
  increases the expressivity of the model considerably.
\item During validation, validator scripts are provided with
  information about the current state of the blockchain.  This
  includes things such as the current slot number, the validity
  interval of the current transaction, and the hash of the
  transaction.  This enables us to ensure that the validation process
  is \i{deterministic}, meaning that the cost of validation can be
  calculated before a transaction is submitted to the blockchain.
  This makes it much simpler for users to calculate transaction fees.
\end{itemize}
  

\noindent\blue{We require more exposition here to motivate these
  extensions.  In particular, say more about determinacy.}

\subsection{A Formal Description of the Extended UTXO Model}
\label{section:xutxo-spec}

In this section we give a formal description of the XUTXO model.  The
description is given in a straightforward set-theoretic form, which
(a) admits an almost direct translation into Haskell, and (b) should
easily be amenable to mechanical formalisation.  This will potentially
allow us to argue formally about smart contracts and to develop tools
for automatic contract analysis.

A validator script is a function of three arguments: the data script
of type $d$, redeemer script of type $r$, and information of type $P$
about the pending transaction (ie, the transaction which is
  just about to take place, assuming that validation succeeds).  If
the script terminates without producing an error, the input-output
pair is valid. The types $d$ and $r$ vary from script to script, and
they are not relevant for our model; $P$ on the other hand is the same
for all pay-to-script transactions on the blockchain, and it plays a
crucial role in determining the kinds of contracts we can write.

The information specified by the type $P$ is the only way for a
validator script to see beyond its own input-output pair and get
information about the transaction that it is part of, and about the
blockchain. This has two implications. First, for any definition of
$P$ there should be a map $\sigma_P : \mathsf{Ledger} \times
\mathsf{Transaction} \times \mathsf{Input} \rightarrow
\mathsf{Script}$ that generates a script with a $P$ value from the
ledger, the current transaction, and the input that is being
validated. Second, by varying $P$ -- and hence the information
available to validator scripts -- we can directly change the kinds of
contracts that can be expressed in the XUTXO model. For example, if we
decide that $P = ()$, the unit type, then our validator scripts would
not get any data about the wider transaction at all. In this setting
even our crowdfunding campaign would be impossible to write because it
requires the script to know the total value of all contributions, and
hence the total value of all inputs to the transaction.  On the other
hand, if $P$ is too large (for example, if it requires searching far
back in the history of the chain), then it could be expensive to
calculate.  Parameterising things over $P$ allows us to explore these
sorts of issues in a unified way.

In the remainder of this docuemtn we will use the type
$\mathsf{Script}$ for all scripts, ignoring the Plutus language types
$d$, $r$ and $P$, and focusing on the blockchain information
generating function $\sigma$ (dropping the subscript).  We expect
$\sigma$ to provide at least the following information ($T$ is the
pending transaction):

\begin{itemize}
  
\item The validity interval of $T$.
\item The hash of $T$.
\item For every input of $T$, its value and the hashes of its
  validator, data, and redeemer scripts.
\item For every output of $T$, its value and the hash of its validator and
  data script.
\item The sum of the values of all unspent outputs (of the current
  blockchain without $T$) which are locked by the validator
  script currently being executed.
\end{itemize}

\subsubsection{Notation}
We generally follow the notation established by
\cite{Zahnentferner18-UTxO}.

\begin{ruledfigure}{H}
\begin{itemize}
\item Types are typeset in $\mathsf{sans~serif}$.

\item All scripts are of type $\mathsf{Script}$.

\item The only operation on $\mathsf{Script}$ from the ledger's
  perspective is applying a validator script to three arguments,
  which is denoted by $\llbracket \cdots \rrbracket :
  \mathsf{Script} \rightarrow \mathsf{Script} \times \mathsf{Script}
    \times \mathsf{Script} \rightarrow \mathbb{V}$ where $\mathbb{V}$
    is some type containing a distinguished value
    \textsf{error}\footnote{We could equally well use the type of
      booleans, but the version involving \textsf{error} fits Plutus
      Core better.}.

\item A record type with fields $\phi_1, \ldots, \phi_n$ of types $T_1,
  \ldots, T_n$ is denoted $(\phi_1 : T_1, \ldots, \phi_n : T_n)$.

\item If $t$ is a value of a record type $T$ and $\phi$ is the name
  of a field of $T$ then $t.\phi$ denotes the value of $\phi$ for
  $t$.
  
\item A list $\lambda$ of type $\mathsf{List[}T\mathsf{]}$ is
    either the empty list $[]$ or a list $e :: \lambda'$ with $head$
    $e$ of type $T$ and $tail$ $\lambda'$ of type
    $\mathsf{List[T]}$. We denote the $i$th element of a list
    $L$ by $L[i]$.
    The concatenation of two lists $\lambda_1$ and
    $\lambda_2$ is denoted $\lambda_1 ::: \lambda_2$.

  \item $x \mapsto f(x)$ denotes an anonymous function.

  \item A cryptographic
    collision-resistant hash of a value $c$ is denoted $c^{\#}$.

  \item If any operation fails (for example, indexing a list out of
    range or trying to spend an output which has already been spent)
    then we assume that the containing script returns \textsf{error}
    immediately.
\end{itemize}
\caption{Basic notation}
\label{fig:basic-notation}
\end{ruledfigure}

\noindent Throughout the document we assume a number of basic types, all of
which we regard as aliases for the type of natural numbers.  These
are shown in Figure~\ref{fig:basic-types}.

\begin{ruledfigure}{H}
  \center{
  \begin{tabular}{rl}
    \s{Value}&: a currency value\\
    \s{SlotNumber}&: a slot number\\
    \s{Address}&: the address of an object in the blockchain\\
    \s{TxId}&: the identifier of a previous transaction on the chain\\
  \end{tabular}
  }
  \caption{Basic types}
  \label{fig:basic-types}
\end{ruledfigure}

\noindent In practice an \textsf{Address} will usually be a hash of
some object (for example, a script), and the blockchain will provide
an efficient way to retrieve the original object given its hash.
Accessing objects indirectly via addresses is helpful because it can
help to reduce memory and disk usage: for example, there may be
scripts for common validation scenarios used in many transactions, and
it is more efficient to store single copies of such scripts rather
than having hundreds of transactions each with their own copy.

We assume that every transaction in a ledger has a unique identifier
of type \s{TxId}: in an implementation this would probably be the
hash of the transaction.

\subsubsection{The Definition of Extended UTXO}
\label{sec:basic-xutxo-defn}

The definitions in this section are essentially the definitions of
UTXO-based cryptocurrencies with scripts \cite{Zahnentferner18-UTxO},
with the following additions:
\begin{itemize}
\item Every transaction now has a validity interval (see above).
\item Every output has an associated datascript.
\item The notion of validity (Figure~\ref{fig:basic-xutxo-validity}) is now
  parameterised by $\sigma$, the function which provides state
  information.
\end{itemize}

\noindent Figure~\ref{fig:basic-xutxo-types} lists the types which
describe transactions in the basic XUTXO model.


%%
\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    
    \s{Output } &= (&\addr: \s{Address},\\
    && \i{val}: \s{Value},\\
    &&  \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef } &= (&\i{id}: \s{TxId},\ \i{index}: \s{Int})\\
    \\
    \s{Input } & = (&\i{outputRef}: \s{OutputRef},\\
                 && \i{validator}: \s{Script},\\
                 && \i{redeemer}: \s{Script})\\
     \\
     \xutxotx\s{ } &= (&\inputs: \s{Set[Input]},\\
     &&\outputs: \s{List[Output]},\\
     &&\i{validityInterval}: \slotnum \times \slotnum,\\
     &&\forge: \s{Value}, \\
     && \fee: \s{Value})\\
     \\
     \s{Ledger } &=&\!\s{List[}\xutxotx\s{]}\\
  \end{arraydefs}
  \]
  \caption{Types for the basic XUTXO model}
  \label{fig:basic-xutxo-types}
\end{ruledfigure}

\noindent Note that a transaction has a \textsf{Set} of inputs but a
\textsf{List} of outputs. We use a list because any subsequent
transaction attempting to use an unspent output $O$ as an input will
have to be able to determine exactly where $O$ came from: thus each
input of a transaction refers to the output which it is trying to
spend via an \s{OutputRef} which specifies the transaction which
produced the output and an index which says which output of the
transaction is required.

Note also that we model a ledger as a simple list of transactions:
a real blockchain ledger will be more complex than this.
\vspace{10pt}

\noindent Following~\cite{Zahnentferner18-UTxO} we define the function

\[
  \unspent : \mathsf{Ledger} \rightarrow \mathsf{Set[OutputRef]}
\]

\noindent by

\begin{align*}
   \unspent([]) &=\emptyset \\
   \unspent(t:::\lambda) &= (\unspent(\lambda) \setminus \spent(\lambda)) \cup t.\inputs.
\end{align*}

\noindent Note that for a completed transaction $t$, $t.\inputs$ is
the set of previously unspent outputs which $t$ has spent.

\vspace{7pt}
\noindent Given a ledger $\lambda$ and a transaction id $\id$, we
denote by $\lambda\langle\id\rangle$ the unique transaction $T$ in
$\lambda$ with $T.\txid = \id$, if it exists. In our abstract model
where $\lambda$ consists of a list of transactions it would suffice to
take $id$ to be the position of $T$ in $\lambda$, but in an
implementation we would probably have $id = T^{\#}$.

Now given an input $i$ to some transaction in a ledger $\lambda$
we define 
$$
\getvalue(i,\lambda) = \lambda\langle i.\outputref.\txid \rangle.\outputs[i].value
$$
This function simply returns the value of the input.

\subsubsection{Validity}
A number of conditions must be satisfied in order for a transaction
$t$ to be considered valid with respect to a ledger $\lambda$ and a
given blockchain-information generating function $\sigma :
\mathsf{Ledger} \times \mathsf{Transaction} \times \mathsf{Input}
\rightarrow \mathsf{Script}$.$\sigma$.  These are listed in
Figure~\ref{fig:basic-xutxo-validity}.  Our definition combines
Definitions 6 and 14 from \cite{Zahnentferner18-UTxO}, differing from
the latter in condition \ref{all-inputs-validate}.


\begin{ruledfigure}{H}
\begin{enumerate}
    \item \label{all-inputs-refer-to-unspent-outputs} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\label{forging} \textbf{Forging:}
      \begin{center}
        \parbox{0.8\textwidth}{
        A transaction with a non-zero \forge{} field is only
        valid if the ledger $\lambda$ is empty
        (that is, if it is the initial
        transaction). Note that the details of this rule depend on the
        monetary policy of the ledger itself, as there may be other
        transactions that forge value.
        }
    \end{center}
      
    \item \label{value-is-preserved} \textbf{Value is preserved}:
    \[
      t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val.
    \]
    \item \label{no-double-spending} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{all-inputs-validate} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i, \lambda).\datascript,i.\redeemer, \sigma(\lambda, t, i)) \rrbracket \ne \textsf{error}.
      \]
    \item\label{validator-scripts-hash} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
\end{enumerate}
\caption{$\sigma$-validity of a transaction $t$ in the basic XUTXO model}
\label{fig:basic-xutxo-validity}
\end{ruledfigure}



\noindent In practice, $\sigma$-validity imposes a limit on the size of the
$\mathsf{Script}$ values of the $\validator$, $\redeemer$ and
$\datascript$ fields and the result of $\sigma$. The validation of a
single transaction must take place within one slot, so the evaluation
of $\llbracket ~ \rrbracket$ cannot take longer than one slot,
approximately twenty seconds.

By parameterising transaction validity by the blockchain information
generating function $\sigma$, we obtain an equivalence class of
transactions that are indistinguishable by validator scripts with
access to the result of $\sigma$.

\subsection{Examples}
\blue{It would be good to have one or more examples here, especially one
  demonstrating what the separation of redeemer and datascript does.}

\newpage
\section{Extended UTXO with Multicurrency Support}
\label{sec:multicurrency}
We now extend the XUTXO model to allow transactions to deal with
multiple currencies.  In addition to the Ada currency, we allow an
unlimited number of other \textit{custom currencies}, possibly
user-defined.  Each currency has a unique identifier.

For this we introduce three new types: see Figure~\ref{fig:more-basic-types}.

\newcommand{\emspace}{\hspace{1em}}
\newcommand{\espace}{\hspace{1en}}

\begin{ruledfigure}{H}
  \center{
  \begin{tabular}{rll}
    \s{Ada}&: &this type represents the fundamental currency in the Cardano
    blockchain, \\
    && and is an alias for the type of natural numbers.\\
  \s{CurrencyID}&: &an identifier for a currency. This is an alias
  for the \s{Address} type from \\
  &  & Figure~\ref{fig:basic-types}.\\
  \s{Values} &: &a map from \s{CurrencyID}s to quantities of the
  corresponding currencies\\
  & & (represented using the \s{Value} type).
  This allows an output to consist of\\
  & & multiple currencies.\\

  \s{Values$^{\pm}$} &: &This is like \s{Values}, but  quantities may be either positive or negative.

  \end{tabular}
  }
  \caption{Extra basic types for the multicurrency XUTXO model}
  \label{fig:more-basic-types}
\end{ruledfigure}

\noindent The changes to the basic XUTXO model are now quite simple.
In the definition of transaction, we allow the \forge{} field to
contain amounts of multiple currencies; the \fee{} field however still
contains a single amount of \s{Ada}. We give the types for the XUTXO
model with multicurrency support in Figure~\ref{fig:mc-xutxo-types}.

\begin{itemize}
  \item\red{Do we want to call \s{Ada} something else, like {BasicCurrency}?
  This XUTXO model isn't necessarily tied to Cardano.}
  \item\red{Do we need some special treatment for Ada in the \forge{} case,
    especially now that we can forge negative amounts?}
\end{itemize}
 

\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    \s{Output\textprime } &= (&\addr: \s{Address},  \red{\textrm{// Or hash of script?}}\\
    && \vals: \s{Values},\\
    && \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef } &= (&\i{id}: \s{TxId}, \i{index}: \s{Int})\\
    \\
    \s{Input } &= (& \i{outputRef}: \sf{OutputRef},\\
                     && \i{validator}: \s{Script},\\
                     & & \i{redeemer}: \s{Script})\\
\\
    \xutxotx\textprime\s{ } &= ( &\inputs: \s{Set[Input]},\\
    &&\outputs: \mathsf{List[Output\textprime]},\\
    &&\i{validityInterval}: \slotnum \times \slotnum,\\
    &&\forge: \s{Values$^\pm$}, \\
    &&\fee: \s{Ada})\\
    \\
    \s{Ledger\textprime } &=&\!\s{List[}\xutxotx\textprime\s{]}\\
\end{arraydefs}
  \]
  \caption{Types for the XUTXO model with multicurrency support}
  \label{fig:mc-xutxo-types}
\end{ruledfigure}


\vspace{10pt}
\noindent The validity conditions must also be updated to take account
of multiple currencies: Figure~\ref{fig:mc-xutxo-validity} contains
the details.  We use the definitions of \unspent{}  and
\getvalue{} from Section~\ref{sec:basic-xutxo-defn} unchanged.

\begin{ruledfigure}{H}
  \begin{enumerate}
    \item \label{all-inputs-refer-to-unspent-outputs-2} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\label{forging-2} \textbf{Forging$^{\prime}$.}
      \begin{center}
        \parbox{0.8\textwidth}{
          A transaction $t$ with a non-zero \forge{} field is only valid if for
          every key $h$ in $t.\forge$, there exists $i \in t.\inputs$
          and $(a,v,d) \in i.\outputs$ with $a =h$; in other words, some input
          must spend an output whose address is $h$.
          }
      
      \end{center}
    \item \label{value-is-preserved-2} \textbf{Value is preserved \red{(fix this)}}:
    \[
      t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val
    \]
    \item \label{no-double-spending-2} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{all-inputs-validate-2} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i,
    \lambda).\datascript,i.\redeemer, \sigma(\lambda, t, i))
    \rrbracket \ne \textsf{error}.
      \]
    \item\label{validator-scripts-hash-2} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
  \end{enumerate}
  \caption{$\sigma$-validity of a transaction $t$ in the multicurrency XUTXO model}
  \label{fig:mc-xutxo-validity}

\end{ruledfigure}

\paragraph{Monetary policies for custom currencies.}
The \textbf{Forging$^{\prime}$}
rule enables custom currencies to implement their own monetary
policies: for example, one might wish to place some limit on the
amount of a currency that can be forged, or restrict the creation of
the currency to owners of particular public keys.

The idea is that a custom currency has a monetary policy which is
defined by some script $H$, and the hash $h = H^{\#}$ is used as the
identifier of the currency.  Whenever a new quantity of the currency
is forged, rules~\ref{forging-2}, \ref{all-inputs-validate-2}, and
\ref{validator-scripts-hash-2} imply that $H$ must be executed; $H$ is
provided with the \forge{} field of the transaction via $\sigma$, and
so it knows how much of the currency is to be forged and can respond
appropriately.

The fact that \forge{} values are allowed to be negative means we can
also \textit{destroy} quantities of custom currencies.

The advantage of this scheme is that custom currencies can be handled
entirely within the smart contract system, without the need to
introduce any extra blockchain infrastructure such as a central
regsitry of custom currencies.


\subsection{Examples}
\blue{Show how to define new currencies and do NFTs.}

\section{Non-fungible tokens}
A non-fungible token (NFT) is a unique object which can be transferred
to another user, but not duplicated.  NFTs have proven useful in a number
of blockchain applications.


\section{What else do we need to worry about?}
\begin{itemize}
\item Do we need to worry about who signs the various scripts, or is that
  something the wallet deals with?
\item Is the number of inputs and/or outputs to a transaction always nonzero?
  Now that we're allowed to destroy currency, maybe we can have transactions
  with no outputs.
\item Do we want to include \s{PayToPubKey} transactions in the specification?
  We definitely want a special case for this in the implementation, but you
  can do it with the general scripts framework anyway.
\item Who's responsible for looking after the scripts, and where are they kept?
  Presumably scripts will be stored in the chain, but how do they get there?
\item I'm still a bit confused about where the validator for an output
  $O$ comes from.  In our model, the validator $V$ is supplied as part
  of a transaction input, but then we require that $O.\addr = V^\#$.
  This means that $V$ must exists at the time that $O$ is created (as
  you'd expect), so why is $V$ not just part of $O$, rather than being
  part of the input?  Is this anything other than a conceptual
  difference?
  
\end{itemize}



%% \section{More stuff}

%% When $T$ wants to unlock $O$,
%% the redeemer for the appropriate input of $T$ is applied to three arguments:
%% \begin{itemize}
%% \item A \textit{datascript}, provided by the producer $S$.
%% \item A \textit{validator} script, provided by the producer $S$. 
%% \item A \textit{redeemer} script, provided by the consumer $T$.  
%% \end{itemize}

%% \blue{The GitHub page on Extended UTXO at
%%   https://github.com/input-output-hk/plutus/tree/master/docs/extended-utxo
%%   says ``The validator script must be submitted as part of the
%%   consuming transaction's input, but its content is determined by the
%%   producing transaction.''. I'm finding this difficult to explain.}


%%  When $T$ wants to unlock $O$, the validator for $O$ of $T$ is applied
%%  to three arguments: the redeemer script, the data script, and
%%  information (supplied by the slot leader) about the current
%%  transaction and the state of the blockchain, described by some type
%%  $P$.

%% If the result evaluates to anything other than the Plutus Core
%% \texttt{error} term then validation succeeds and the output is unlocked.

%% Every input of a transaction has an associated redeemer and for the
%% transaction to proceed the redemption of every input must be validated
%% successfully.

%% In the current Plutus implementation, the type $P$ contains the
%% following information:

%% \begin{itemize}
%% \item The validity interval of $T$.
%% \item The hash of $T$.
%% \item For every input of $T$, its value and the hashes of its
%%   validator, data, and redeemer scripts (if the input refers to an output
%%   locked by a script) or the public key and signature (if it refers to
%%   an output locked by a public key)
%% \item For every output of $T$, its value and the hash of its validator
%%   and data script, or the public key that owns it
%% %\item The sum of the values of all unspent outputs (of the current
%%   %blockchain without $T$) which are locked by $O$'s validator script.
%% \end{itemize}

%% The expressivity of contracts depends on the choice of $P$, and $P$
%% may be extended in future to include more information if required.

%% \subsection{Extended UTXO and Standard UTXO}

%% \blue{This is really feeble.}

%% Our extended version of the UTXO model genuinely does offer more than
%% the standard version, as implemented by Bitcoin.

%% %% Duncan: Perhaps one approach to explaining this is to start by
%% %% noting that classically we don't think of data values flowing along
%% %% the edges of the utxo graph, but that this is very useful for
%% %% scripts.

%% \subsubsection{Datascripts}
%% \label{sec:datascripts}
%% Datascripts allow us to separate information about the state
%% of the transaction from the validator script, meaning that we can
%% have situations such as a single validator which refunds outputs
%% to addresses contained in the data script (as in the crowdfunding
%% example).  In the Bitcoin model, each output would require a
%% specialised validator, increasing memory usage.
    
%% \subsubsection{Constraining outputs}
%% \label{sec:constraining-outputs}
%% The fact that the validator receives information about the
%% state of the chain allows us to do things like restricting where
%% the output of a transaction goes, so it's possible to construct
%% graphs of transactions where values are constrained to flow down
%% allowed paths. In the classic model if you can validate at all you
%% can always take the money and keep it.

%% \subsubsection{Deterministic Scripts}
%% \label{sec:deterministic-scripts}
%% When core nodes validate an input spending from a pay-to-script
%% address, they supply two pieces of information to the validator
%% script: The structure of the transaction that is being validated (in
%% form of a list of hashes and signatures), and an indication of the
%% current time (expressed in terms of the slot number: see
%% \ref{subsection:blockchains}).  After a transaction has been submitted
%% to the blockchain, it may linger in the transaction pool for some time
%% before being processed by a core node. Allowing validator scripts to
%% know the exact slot number of their validation would therefore make
%% them non-deterministic, in the sense that their result depends on
%% information that is not known at the time the transaction is
%% submitted.  Non-determinism is a problem because it makes it
%% impossible to accurately compute the gas cost of consuming a
%% pay-to-script output, running counter to our stated goals of
%% measurable and predictable resource consumption.

%% In the Extended UTXO model we add a \emph{validity interval}, an
%% interval of slots, to each transaction's metadata. Core nodes only
%% attempt to validate transactions whose validity interval contains the
%% current slot. When a scripted transaction input is validated, the
%% transaction's validity interval is passed to the validator script,
%% providing information about the current time. Since the validity
%% interval is known at the time the transaction is submitted to the
%% chain, transaction validation in Plutus is completely deterministic.

%% As a result, the exact amount of gas that is required to run the script can be 
%% calculated in advance (by running it), and users do not risk being surprised by 
%% failed validations that still incur fees.    


\bibliographystyle{plain} %% ... or whatever
\bibliography{extended-utxo-specification}


\end{document}
