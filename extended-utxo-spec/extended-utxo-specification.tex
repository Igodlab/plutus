%% Extended UTXO Specification

\newcommand\version{-1}

\title{Formal Specification of the Extended UTXO Model\\--- \\
  \red{\textsf{PRELIMINARY DRAFT!}}}

\pagestyle{plain}
\date{1st May 2019}
\author{}

\documentclass[a4paper]{article}

\usepackage{blindtext, graphicx}
\usepackage{url}

% *** MATHS PACKAGES ***
%
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}

% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
\usepackage{float}  %% Try to improve placement of figures.  Doesn't work well with subcaption package.
\usepackage{subcaption}
\usepackage{caption}

% Stuff for splitting figures over page breaks
%\DeclareCaptionLabelFormat{continued}{#1~#2 (Continued)}
%\captionsetup[ContinuedFloat]{labelformat=continued}

% correct bad hyphenation here
\hyphenation{}

\usepackage{subfiles}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}


%%% General Misc. Definitions

%% A version of ^{\prime} for use in text mode
\makeatletter
\DeclareTextCommand{\textprime}{\encodingdefault}{%
  \mbox{$\m@th'\kern-\scriptspace$}% 
}
\makeatother

\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\redfootnote}[1]{\red{\footnote{\red{#1}}}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\bluefootnote}[1]{\blue{\footnote{\blue{#1}}}}

\renewcommand{\i}{\textit}  % Just to speed up typing: replace these in the final version
\renewcommand{\t}{\texttt}  % Just to speed up typing: replace these in the final version
\newcommand{\s}{\textsf}  % Just to speed up typing: replace these in the final version

\theoremstyle{definition}  %% This applies to all following \newtheorem items
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\newenvironment{arraydefs}[1]{\setlength{\arraycolsep}{0pt}\begin{array}{#1}}{\end{array}}
%
% This is just the array environment with the column separation set to 0.
% This is to enable us to get things like
%
%%   X = (field1: type1,
%         field2: type2,
%         ...
%
% without a space after the ')'. Unfortunately you have to manually insert a space
% at the end of the X so you don't get X=
% There's presumably a better way to do this.
%
% You can also use something like
%
%    \begin{tabular}{r@{ }l@{}l} ...
%
% but the spacing is arguably worse.


\newcommand\rfskip{7pt}
\newenvironment{ruledfigure}[1]{\begin{figure}[#1]\hrule\vspace{\rfskip}}{\vspace{\rfskip}\hrule\end{figure}}


\newcommand{\List}[1]{\ensuremath{\s{List}[#1]}}
\newcommand{\Set}[1]{\ensuremath{\s{Set}[#1]}}
\newcommand{\Map}[2]{\ensuremath{\s{Map}[#1,#2]}}
\newcommand{\dom}{\ensuremath{\mathop{\mathrm{dom}}}}

% Macros for xutxo things.
\newcommand{\mi}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\txid}{\mi{txid}}
\newcommand{\idx}{\mi{index}}
\newcommand{\inputs}{\mi{inputs}}
\newcommand{\outputs}{\mi{outputs}}
\newcommand{\forge}{\mi{forge}}
\newcommand{\fee}{\mi{fee}}
\newcommand{\addr}{\mi{addr}}
\newcommand{\val}{\mi{value}}  %% \value is already defined
\newcommand{\nativeval}{\mi{nativeValue}}
\newcommand{\customvals}{\mi{customValues}}
\newcommand{\customforge}{\mi{customForge}}

\newcommand{\validator}{\mi{validator}}
\newcommand{\redeemer}{\mi{redeemer}}
\newcommand{\datascript}{\mi{datascript}}
\newcommand{\outputref}{\mi{outputRef}}
\newcommand{\txin}{\mi{in}}
\newcommand{\txout}{\mi{out}}
\newcommand{\id}{\mi{id}}
\newcommand{\getvalue}{\msf{getvalue}}

\newcommand{\msf}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\slotnum}{\msf{SlotNumber}}
\newcommand{\spent}{\msf{spentOutputs}}
\newcommand{\unspent}{\msf{unspentOutputs}}
\newcommand{\xutxotx}{\msf{XUtxoTx}}

\newcommand{\valuetype}{\ensuremath{\s{Value}}}
\newcommand{\newvaluetype}{\ensuremath{\s{Value}^{\prime}}}

\newcommand{\valuemap}{\ensuremath{\s{ValueMap}}}
\newcommand{\newvaluemap}{\ensuremath{\s{ValueMap}^{\prime}}}




\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  mathescape=true,
  escapeinside={|}{|}   %% Inside listings you can say things like |\textit{blah blah}|
}


%% ------------- Start of document ------------- %%

\begin{document}
\maketitle

\section{Introduction: The Extended UTXO Model}
\label{sec:intro}
The Cardano blockchain~\cite{Cardano} uses a variant of the \textit{Unspent
  Transaction Output} (UTXO) model used by Bitcoin.  Transactions
consume \textit{unspent outputs} (UTXOs) from previous transactions
and produce new outputs which can be used as inputs to later
transactions.  Unspent outputs are the liquid funds on the
blockchain. Users do not have individual accounts, but rather have a
software \textit{wallet} on a smartphone or PC which manages UTXOs on
the blockchain and can initiate transactions involving UTXOs owned by
the user.  Every core node on the blockchain maintains a record of all
of the currently unspent outputs, the \textit{UTXO set}; when outputs
are spent, they are removed from the UTXO set.

Our main concern here is to facilitate the implementation of
\textit{smart contracts}: programs which perform automated and
irrevocable transfer of funds on the blockchain, subject to certain
conditions being met.  A smart contract may involve multiple
transactions, and our aim is to define a transaction model which
enables the implementation of highly expressive contracts.

\subsection{Structure of the document}
\label{sec:doc-structure}
This document proposes three extensions of the basic UTXO model, each
one more general than the previous one (XUTXO stands for
\textit{Extended UTXO}):

\begin{itemize}
  \item \textbf{XUTXO-1} (Section~\ref{sec:xutxo-1}): this extends the
    basic UTXO model with enhanced scripting features, allowing the
    implementation of complex smart contracts.
  \item \textbf{XUTXO-2} (Section~\ref{sec:xutxo-2}): this adds
    multicurrency features to XUTXO-1, allowing users to define
    \textit{custom currencies}.
  \item \textbf{XUTXO-3} (Section~\ref{sec:xutxo-3}): this adds direct
    support for non-fungible tokens to XUTXO-2.
\end{itemize}

\noindent We give formal specifications of each of these versions,
based on the models appearing in the
papers~\cite{Zahnentferner18-Chimeric} and
\cite{Zahnentferner18-UTxO}.

\medskip

The rationale for providing three separate specifications is that (1)
introducing extensions one by one clarifies the structure of the
models and makes it easier to explain the relevant design decisions,
and (2) it is possible that a particular blockchain might not need the
full power of XUTXO-3 and so could use a simpler model, perhaps with
less computational overhead.

\bigskip

\noindent Before presenting the extended models we will define some
basic notation and give a little background on the standard UTXO
model.


\section{Notation}
This section defines some basic notation.  We generally follow the
notation established by \cite{Zahnentferner18-UTxO}.

\begin{ruledfigure}{H}
\begin{itemize}
\item Types are typeset in $\mathsf{sans~serif}$.

\item All scripts are of type $\mathsf{Script}$.

\item The only operation on $\mathsf{Script}$ from the ledger's
  perspective is applying a validator script to three arguments,
  which is denoted by $\llbracket \cdots \rrbracket :
  \mathsf{Script} \rightarrow \mathsf{Script} \times \mathsf{Script}
    \times \mathsf{Script} \rightarrow \mathbb{V}$ where $\mathbb{V}$
    is some type containing a distinguished value
    \textsf{error}\footnotemark.

\item A record type with fields $\phi_1, \ldots, \phi_n$ of types $T_1,
  \ldots, T_n$ is denoted by $(\phi_1 : T_1, \ldots, \phi_n : T_n)$.

\item If $t$ is a value of a record type $T$ and $\phi$ is the name
  of a field of $T$ then $t.\phi$ denotes the value of $\phi$ for
  $t$.
  
\item A list $\lambda$ of type $\List{T}$ is
    either the empty list $[]$ or a list $e :: \lambda'$ with $head$
    $e$ of type $T$ and $tail$ $\lambda'$ of type
    $\List{T}$. We denote the $i$th element of a list
    $L$ by $L[i]$.
    The concatenation of two lists $\lambda_1$ and
    $\lambda_2$ is denoted $\lambda_1 ::: \lambda_2$.

  \item For two types $K$ and $V$, $\Map{K}{V}$ denotes the type of
    partial functions from \textit{keys} in $K$ to \textit{values} in
    $V$.  If $m$ is such a map then $\dom m$ (the \textit{domain} of
    $m$) is the set of keys of $m$ (ie, $K$).  Given a map $m$ and a
    key $k \in \dom m$, we denote the result of looking up $k$ in $m$
    by $m[k]$.  Equality for maps is defined in the obvious way: $m_1
    = m_2$ if and only if $\dom m_1 = \dom m_2$ and $m_1[k] = m_2[k]$
    for all $k \in \dom m_1$ (assuming we have decidable equality in $V$).
    
  \item If the type $V$ is a monoid with binary operation $+$ (for
    example, a numeric type) and $f, g \in \Map{K}{V}$ then we define
    their sum $f+g \in \Map{K}{V}$ with domain $\dom (f+g) = \dom f
    \cup \dom g$ by
    \[
    (f+g)[k] =
    \left\{ \begin{array}{ll}
        f[k] + g[k] & \mbox{if $k \in \dom f \cap \dom g$}\\
        f[k] & \mbox{if $k \in \dom f \setminus \dom g$}\\
        g[k] & \mbox{if $k \in \dom g \setminus \dom f$}
      \end{array}
      \right.
      \]
      We generalise this to the sum of a finite number of maps using
      the $\sum$ notation in the usual way.  Note that the type
      $\Map{K}{V}$ itself becomes a monoid under the operation $+$
      which we have just defined (with the empty map as identity element).

    \item $x \mapsto f(x)$ denotes an anonymous function.

  \item A cryptographic
    collision-resistant hash of a value $c$ is denoted $c^{\#}$.

  \item If any operation fails (for example, indexing a list out of
    range or trying to spend an output which has already been spent)
    then we assume that the containing script returns \textsf{error}
    immediately.
\end{itemize}
\caption{Basic notation}
\label{fig:basic-notation}
\end{ruledfigure}

\footnotetext{We could equally well use the type of booleans, but the
  version involving \textsf{error} fits Plutus Core better.}


\noindent Throughout the document we assume a number of basic types, all of
which we regard as aliases for the type of natural numbers.  These
are shown in Figure~\ref{fig:basic-types}.

\begin{ruledfigure}{H}
  \center{
  \begin{tabular}{rl}
    \valuetype&: a currency value\\
    \s{SlotNumber}&: a slot number\\
    \s{Address}&: the address of an object in the blockchain\\
    \s{TxId}&: the identifier of a previous transaction on the chain\\
  \end{tabular}
  }
  \caption{Basic types}
  \label{fig:basic-types}
\end{ruledfigure}

\noindent In practice an \textsf{Address} will usually be a hash of
some object (for example, a script), and the blockchain will provide
an efficient way to retrieve the original object given its hash.
Accessing objects indirectly via addresses is helpful because it can
help to reduce memory and disk usage: for example, there may be
scripts for common validation scenarios used in many transactions, and
it is more efficient to store single copies of such scripts rather
than having hundreds of transactions each with their own copy.

We assume that every transaction in a ledger has a unique identifier
of type \s{TxId}: in an implementation this would probably be the
hash of the transaction.





\section{The Basic UTXO model: Outputs and scripts}
\label{sec:utxo-intro}

There is no well-defined notion of ownership for UTXOs.  In many
transactions an output will accrue to a single user who is then
entitled to spend it at a later date.  However, in general the notion
of ownership is more complex: an output of a transaction might require
the cooperation of several users before it could be spent, or it might
not be spendable until some other condition has been met (for example
a certain period of time may have to pass).  At the extremes, an
output could be spendable by anyone, or by no-one.

In order to deal with this complexity, an output can be locked by a
\textit{script}, requiring another script to unlock it.  In the
Cardano setting, scripts are Plutus Core
programs~\cite{Plutus-Core-spec} (equivalently, expressions).  In the
basic model, each input to a transaction comes with a \i{validator}
script which checks that the transaction is allowed to spend the
output. To prove that it is allowed to spend an output, the
transaction supplies another script, called the \i{redeemer}\footnote{
  The validator plays a role similar to that of BitCoin's
  \texttt{scriptPubKey} and the redeemer to \texttt{scriptSig}.}.

In a process known as \i{validation}, the validator is run with the
redeemer as input, and if it terminates without an error arising then
the output can be spent.  Before a transaction can proceed, all inputs
must be successfully validated: if one or more inputs fails to validate
then the transaction is rejected (\blue{is this true?}).

A simple example of this is a \i{pay-to-pubkey} script, where the
redeemer consists of a signature for the current transaction produced
using a private key belonging to the owner of the output.  The
validator (provided by the owner of the output) would check the
signature using a known public key: if the public key corresponds to
the private key then validation succeeds, otherwise it fails.  Thus
the output can only be spent by the owner of the relevant private key

\paragraph{Blockchain terminology.}
\label{sec:blockchain-terminology}
We require a little blockchain background. A \textit{blockchain} is a
ledger consisting of a sequence of \textit{blocks}, each block
containing a number of transactions (and possibly other data).  A
typical blockchain will be maintained by a peer-to-peer network
consisting of \textit{core nodes} who compete to execute users'
transactions and create new blocks, generally receiving some monetary
reward for doing so (for example, in order to have a transaction
executed on the chain, users may have to pay a \textit{fee} calculated
from the transaction size and execution time). After a new block has
been created, it will be propagated to the rest of the network, which
will eventually reach consensus on the current state of the
blockchain.  The opportunity to create a new block is known as a
\textit{slot}: slots occur at regular intervals (about once every 20
seconds on Cardano), and hence the current \textit{slot number} can be
used as a proxy for time on the blockchain (using real times would
lead to problems with accuracy and synchronisation).


\section{XUTXO-1: Enhanced scripting}
\label{sec:xutxo-1}
The XUTXO-1 model adds the following new features to the model 
proposed in~\cite{Zahnentferner18-UTxO}:

\begin{itemize}
\item Every transaction has a \textit{validity interval}, consisting
  of two slot numbers: a core node will only process the transaction
  if the current slot number lies within the transaction's validity
  interval.

\item We introduce a new type of script called a \i{data script}, and
  each unspent output has a (possibly empty) data script associated
  with it.  The introduction of the data script increases the
  expressivity of the model considerably. For example, one can use the
  datascript to propagate state between transactions, and this can be
  used to give a contract the structure of a finite state machine.

\item During validation, validator scripts are provided with
  information about the current state of the blockchain.  This
  includes things such as the current slot number, the validity
  interval of the current transaction, and the hash of the
  transaction.  This enables us to ensure that the validation process
  is \i{deterministic}, meaning that the cost of validation can be
  calculated before a transaction is submitted to the blockchain.
  This makes it much simpler for users to calculate transaction fees.
\end{itemize}
  

\noindent\blue{We require more exposition here to motivate these
  extensions.  In particular, say more about determinacy.}

A validator script is a function of three arguments: the data script
of type $d$, redeemer script of type $r$, and information of type $P$
about the pending transaction (ie, the transaction which is
  just about to take place, assuming that validation succeeds).  If
the script terminates without producing an error, the input-output
pair is valid. The types $d$ and $r$ vary from script to script, and
they are not relevant for our model; $P$ on the other hand is the same
for all pay-to-script transactions on the blockchain, and it plays a
crucial role in determining the kinds of contracts we can write.

The information specified by the type $P$ is the only way for a
validator script to see beyond its own input-output pair and get
information about the transaction that it is part of, and about the
blockchain. This has two implications. First, for any definition of
$P$ there should be a map $\sigma_P : \mathsf{Ledger} \times
\mathsf{Transaction} \times \mathsf{Input} \rightarrow
\mathsf{Script}$ that generates a script with a $P$ value from the
ledger, the current transaction, and the input that is being
validated. Second, by varying $P$ -- and hence the information
available to validator scripts -- we can directly change the kinds of
contracts that can be expressed in the XUTXO model. For example, if we
decide that $P = ()$, the unit type, then our validator scripts would
not get any data about the wider transaction at all. In this setting
even our crowdfunding campaign would be impossible to write because it
requires the script to know the total value of all contributions, and
hence the total value of all inputs to the transaction.  On the other
hand, if $P$ is too large (for example, if it requires searching far
back in the history of the chain), then it could be expensive to
calculate.  Parameterising things over $P$ allows us to explore these
sorts of issues in a unified way.

In the remainder of this document we will use the type
$\mathsf{Script}$ for all scripts, ignoring the Plutus language types
$d$, $r$ and $P$, and focusing on the blockchain information
generating function $\sigma$ (dropping the subscript).  We expect
$\sigma$ to provide at least the following information ($T$ is the
pending transaction):

\begin{itemize}
  
\item The validity interval of $T$.
\item The hash of $T$.
\item For every input of $T$, its value and the hashes of its
  validator, data, and redeemer scripts.
\item For every output of $T$, its value and the hash of its validator and
  data script.
\item The sum of the values of all unspent outputs (of the current
  blockchain without $T$) which are locked by the validator
  script currently being executed.
\end{itemize}

\subsection{A Formal Description of the XUTXO-1 Model}
\label{section:xutxo-spec}

In this section we give a formal description of the XUTXO-1 model.  The
description is given in a straightforward set-theoretic form, which
(a) admits an almost direct translation into Haskell, and (b) should
easily be amenable to mechanical formalisation.  This will potentially
allow us to argue formally about smart contracts and to develop tools
for automatic contract analysis.

The definitions in this section are essentially the definitions of
UTXO-based cryptocurrencies with scripts \cite{Zahnentferner18-UTxO},
with the following additions:
\begin{itemize}
\item Every transaction now has a validity interval (see above).
\item Every output has an associated datascript.
\item The notion of validity (Figure~\ref{fig:xutxo-1-validity}) is now
  parameterised by $\sigma$, the function which provides state
  information.
\end{itemize}

\noindent Figure~\ref{fig:xutxo-1-types} lists the types which
describe transactions in the basic XUTXO model.


%%
\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    
    \s{Output } &= (&\addr: \s{Address},\\
    && \i{val}: \valuetype,\\
    &&  \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef } &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input } & = (&\i{outputRef}: \s{OutputRef},\\
                 && \i{validator}: \s{Script},\\
                 && \i{redeemer}: \s{Script})\\
     \\
     \xutxotx\s{ } &= (&\inputs: \Set{\s{Input}},\\
     &&\outputs: \List{\s{Output}},\\
     &&\i{validityInterval}: \slotnum \times \slotnum,\\
     && \fee: \valuetype,\\
     &&\forge: \valuetype) \\
     \\
     \s{Ledger } &=&\!\List{\xutxotx}\\
  \end{arraydefs}
  \]
  \caption{Types the XUTXO-1 model}
  \label{fig:xutxo-1-types}
\end{ruledfigure}

\subsubsection{Remarks}
\paragraph{Inputs and outputs. } Note that a transaction has a
\textsf{Set} of inputs but a \textsf{List} of outputs. We use a list
because any subsequent transaction attempting to use an unspent output
$O$ as an input will have to be able to determine exactly where $O$
came from: thus each input of a transaction refers to the output which
it is trying to spend via an \s{OutputRef} which specifies the
transaction which produced the output and an index which says which
output of the transaction is required.

\paragraph{Scripts.}  Validator scripts are the things that determine
the spendability of outputs, and thus the validator for an output must
be created at the same time as the output is.  Conceptually the
validator is part of the output, so it may be rather unexpected that
Figure~\ref{fig:xutxo-1-types} defines the validator to be part of an
\textit{input}, with the output only containing a hash of the
validator.  The rationale for this is that a validator $V$ for an
output $O$ is not required until $O$ is actually spent, which may be
some time after $O$ was created.  Users are charged for storing
scripts on-chain\bluefootnote{Really? How is this charge levied?  Does
  the contract fee include a charge for the size of the scripts
  involved?} , so $V$ should be stored off-chain until $O$ is required
as an input to a transaction $T$.  At this point, $V$ would be
uploaded to the blockchain as part of $T$ and the initiator of the
contract (who may not be the owner of $O$) would become responsible
for the storage charges.  Since $O$ contains a hash of $V$, it can be
checked that $V$ really is the correct validator for $O$ (see
rule~\ref{rule:all-inputs-validate} in
Figure~\ref{fig:xutxo-1-validity}).  This strategy is not applied to
datascripts since, as the name would suggest, we expect them to be
small pieces of data (public keys, for example) which would not incur
large storage charges.  \red{I'm not very clear about this stuff.  In
  practice, will the consuming transaction contain the actual redeemer
  and validator, or just a hash? (Presumably the latter, since then
  scripts can be re-used at low cost).  When and how do the scripts
  get stored on the chain?}

\paragraph{Signing scripts.}  Before a smart contract is uploaded to
the blockchain, participants will examine it to satisfy themselves
that they are happy with its terms.  In particular, they should be
satisfied with the scripts involved in validation.  However, these
scripts are run on-chain, and the question arises of how one knows
that the scripts that run on-chain are the ones that were examined
beforehand.  This is dealt with by having users digitally sign the
scripts, with the signatures being verified prior to on-chain
execution.  In the XUTXO-1 model, the validator and datascript are
signed by the producer of an output, and the redeemer is signed by the
consumer.  The details of this are outside the scope of this document.
\red{So where are the details actually specified? Also, the producer and
  consumer aren't people, they're transactions.  There may not be any
  people involved at all.}

\paragraph{Ledger structure.} We model a ledger as a simple
list of transactions: a real blockchain ledger will be more complex
than this, but the only property that we really require is that
transactions in the ledger have some kind of address which allows them
to be uniquely identified and retrieved.

\subsubsection{Validity}
\label{sec:xutxo-1-validity}
A number of conditions must be satisfied in order for a transaction
$t$ to be considered valid with respect to a ledger $\lambda$ and a
given blockchain-information generating function $\sigma :
\mathsf{Ledger} \times \mathsf{Transaction} \times \mathsf{Input}
\rightarrow \mathsf{Script}$.  In order to define these we require a
couple of auxiliary functions.  Firstly,
following~\cite{Zahnentferner18-UTxO} we define

\[
  \unspent : \mathsf{Ledger} \rightarrow \Set{\s{OutputRef}}
\]

\noindent by

\begin{align*}
   \unspent([]) &=\emptyset \\
   \unspent(t:::\lambda) &= (\unspent(\lambda) \setminus \spent(\lambda)) \cup t.\inputs.
\end{align*}

\noindent Note that for a completed transaction $t$, $t.\inputs$ is
the set of previously unspent outputs which $t$ has spent.

\medskip
\noindent Given a ledger $\lambda$ and a transaction id $\id$, we
denote by $\lambda\langle\id\rangle$ the unique transaction $T$ in
$\lambda$ with $T.\txid = \id$, if it exists. In our abstract model
where $\lambda$ consists of a list of transactions it would suffice to
take $id$ to be the position of $T$ in $\lambda$, but in an
implementation we would probably have $id = T^{\#}$.

\medskip
\noindent Now given an input $i$ to some transaction in a ledger
$\lambda$ we define
$$
\getvalue(i,\lambda) = \lambda\langle i.\outputref.\txid \rangle.\outputs[i.\outputref.\idx].\val
$$
This function simply returns the value of the input.

\bigskip

\noindent We can now define what it means for a transaction to be valid: see
Figure~\ref{fig:xutxo-1-validity}.  Our definition combines
Definitions 6 and 14 from \cite{Zahnentferner18-UTxO}, differing from
the latter in condition \ref{rule:all-inputs-validate}.


\begin{ruledfigure}{H}
\begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\label{rule:forging} \textbf{Forging:}
      \begin{center}
        \parbox{0.8\textwidth}{
        A transaction with a non-zero \forge{} field is only
        valid if the ledger $\lambda$ is empty
        (that is, if it is the initial
        transaction). Note that the details of this rule depend on the
        monetary policy of the ledger itself, as there may be other
        transactions that forge value. \red{Expand on this.  What other transactions?  Mining?}
        }
    \end{center}
      
    \item \label{rule:value-is-preserved} \textbf{Value is preserved}:
    \[
      t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val.
    \]
    \item \label{rule:no-double-spending} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i, \lambda).\datascript,i.\redeemer, \sigma(\lambda, t, i)) \rrbracket \ne \textsf{error}.
      \]
    \item\label{rule:validator-scripts-hash} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
\end{enumerate}
\caption{$\sigma$-validity of a transaction $t$ in the XUTXO-1 model}
\label{fig:xutxo-1-validity}
\end{ruledfigure}



\noindent In practice, $\sigma$-validity imposes a limit on the size
of the $\mathsf{Script}$ values of the $\validator$, $\redeemer$ and
$\datascript$ fields and the result of $\sigma$. The validation of a
single transaction must take place within one slot, so the evaluation
of $\llbracket ~ \rrbracket$ cannot take longer than one slot
(approximately twenty seconds on the Cardano blockchain).

By parameterising transaction validity by the blockchain information
generating function $\sigma$, we obtain an equivalence class of
transactions that are indistinguishable by validator scripts with
access to the result of $\sigma$.

\subsection{Examples}
\blue{It would be good to have one or more examples here, especially one
  demonstrating what the separation of redeemer and datascript does.}

\newpage
\section{XUTXO-2: multicurrency support}
\label{sec:xutxo-2}
We now extend the XUTXO model to allow transactions to deal with
multiple currencies.  We assume that the underlying blockchain has a
unique \textit{native currency} which is the fundamental currency used
for paying fees, for example.  The native currency of the Cardano
blockchain is Ada.

In addition to the native currency, the XUTXO-2 model allows an
unlimited number of other \textit{custom currencies}, possibly
user-defined.  Each custom currency has a unique identifier; the
native currency is handled separately and has no identifier.  To
support custom currencies we introduce three new types: see
Figure~\ref{fig:more-basic-types}.

\newcommand{\emspace}{\hspace{1em}}
\newcommand{\espace}{\hspace{1en}}

\begin{ruledfigure}{H}
  \center{
  \begin{tabular}{rll}
  \s{CurrencyID}&: &an identifier for a custom currency. This is an alias
  for the \s{Address} type\\
  & & from Figure~\ref{fig:basic-types}.\\
  \valuemap &: &a map from \s{CurrencyID}s to quantities of the
  corresponding currencies\\
  & & (represented using the non-negative \valuetype{} type). This allows an output\\
  & & to contain quantities of multiple custom currencies in addition to some \\
  & & quantity (possibly zero) of the native currency.\\

  \s{ValueMap$^{\pm}$} &: &This is like \valuemap{}, but quantities may be either positive or negative.
  \end{tabular}
  }
  \caption{Extra basic types for the XUTXO-2 model}
  \label{fig:more-basic-types}
\end{ruledfigure}

\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    \s{Output}_2 &= (&\addr: \s{Address},\\
    && \val: \valuetype\\
    && \customvals: \valuemap,\\
    && \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef}_2 &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input}_2 &= (& \i{outputRef}: \sf{OutputRef}_2,\\
                     && \i{validator}: \s{Script},\\
                     & & \i{redeemer}: \s{Script})\\
\\
    \xutxotx_2 &= ( &\inputs: \Set{\s{Input}_2},\\
    &&\outputs: \List{\s{Output}_2},\\
    &&\i{validityInterval}: \slotnum \times \slotnum,\\
    &&\fee: \valuetype,\\
    &&\forge: \valuetype,\\
    &&\customforge: \valuemap^{\pm})\\
    \\
    \s{Ledger}_2 &=&\!\List{\xutxotx_2}\\
\end{arraydefs}
  \]
  \caption{Types for the XUTXO-2 model}
  \label{fig:xutxo-2-types}
\end{ruledfigure}

\noindent The changes to the basic XUTXO-1 types are now quite simple: see Figure~\ref{fig:xutxo-2-types}.
We add a \valuemap{} to the \s{Output} type, representing values of custom
currencies; we also add a \customforge{} field of type
$\valuemap^{\pm}$ to transactions to allow the creation and
destruction of tokens in custom currencies; the supply of a custom
currency can be reduced by forging a negative amount of that currency.

The fields \val, \fee, and \forge{} all represent quantities of the
native currency, as in the XUTXO-1 model.

\medskip
\noindent The validity conditions must also be updated to take account
of multiple currencies: Figure~\ref{fig:xutxo-2-validity} contains
the details.

\begin{ruledfigure}{H}
  \begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs-2} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\textbf{Forging:}\\\\
      \begin{minipage}{0.85\textwidth}
          \begin{enumerate}
          \item
              A transaction with a non-zero \forge{} field is only
            valid if the ledger $\lambda$ is empty
            (that is, if it is the initial
            transaction). 
          \item \label{rule:custom-forge}
            A transaction with a non-empty \customforge{} field is
            only valid if for every key $h$ in $t.\customforge$, there
            exists $i \in t.\inputs$ and $(a,v,d) \in i.\outputs$ with
            $a =h$; in other words, some input must spend an output
            whose address is $h$.
          \end{enumerate}
          \end{minipage}
    \item \textbf{Value are preserved}\\
      \begin{minipage}{0.85\textwidth}
          \begin{enumerate}
          \item\label{rule:native-value-is-preserved-2}
            \[
            t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val
            \]

          \item\label{rule:custom-values-are-preserved-2}
            \[
            t.\customforge + \sum_{i \in t.\inputs} \s{getCustomValues}(i, \lambda) = \sum_{o \in t.\outputs} o.\customvals
            \]
          \end{enumerate}
          
          \end{minipage}
    \item \label{rule:no-double-spending-2} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate-2} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i,
    \lambda).\datascript,i.\redeemer, \sigma(\lambda, t, i))
    \rrbracket \ne \textsf{error}.
      \]
    \item\label{rule:validator-scripts-hash-2} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
  \end{enumerate}
  \caption{$\sigma$-validity of a transaction $t$ in the XUTXO-2 model}
  \label{fig:xutxo-2-validity}

\end{ruledfigure}

We use the definitions of \unspent{}  and
\getvalue{} from Section~\ref{sec:xutxo-1-validity} unchanged,
but we also require a function to retrieve the values of
custom currencies from inputs. If $t$ is a transaction in a ledger
$\lambda$ and $i \in t.\inputs$, then we define 
$$
\s{getCustomValues}(i,\lambda) = \lambda\langle i.\outputref.\txid \rangle.\outputs[i.\outputref.\idx].\customvals
$$
\noindent If any of the indexing operations here fail then the
transaction is invalid.

\paragraph{Note.} In rule~\ref{rule:custom-values-are-preserved-2}, $+$ and $\sum$ are the
sum of maps as defined in Figure~\ref{fig:basic-notation}. Essentially
we require that the quantities of each of the individual custom currencies
involved in the transaction are preserved.  Recall that values in
$\customforge$ can be negative whereas values in outputs must
be non-negative.  Thus rule~\ref{rule:custom-values-are-preserved-2} implies
that a transaction is invalid if it attempts to destroy more of a currency
than is actually available in its inputs.


\paragraph{Monetary policies for custom currencies.}
The new \textbf{Forging}
rule enables custom currencies to implement their own monetary
policies: for example, one might wish to place some limit on the
amount of a currency that can be forged, or restrict the creation of
the currency to owners of particular public keys.

The idea is that a custom currency has a monetary policy which is
defined by some script $H$, and the hash $h = H^{\#}$ is used as the
identifier of the currency\footnotemark.  Whenever a new quantity of
the currency is forged, rules~\ref{rule:custom-forge},
\ref{rule:all-inputs-validate-2}, and
\ref{rule:validator-scripts-hash-2} imply that $H$ must be executed;
$H$ is provided with the \forge{} field of the transaction via
$\sigma$, and so it knows how much of the currency is to be forged and
can respond appropriately.

The advantage of this scheme is that custom currencies can be handled
entirely within the smart contract system, without the need to
introduce any extra blockchain infrastructure such as a central
registry of custom currencies.

\footnotetext{In fact it is not quite enough to use the hash of the
  script here, because many different currencies might wish to use the
  same policy and hence the same script.  One way to remedy this is to
  embed a reference to an unspent output in the script and say that
  the currency can only be forged if the referenced output is spent at
  the same time, so it can only be forged once. \red{I don't think
    that's quite what we want here though: we have one opportunity
    to forge the currency, then we can't make any more.}}
  
\subsection{Examples}
\subsubsection{Non-fungible tokens}
A non-fungible token (NFT) is a unique object which can be transferred
to another user, but not duplicated.  NFTs have proven useful in a
number of blockchain applications (see~\cite{ERC-721} for example);
for example, they can represent ownership of some object in a game.

\medskip

An important example that motivated the design XUTXO-2 model was the
idea of implementing NFTs as currencies with a supply of 1. If NFTs are
used to represent different stakes in a contract, then a single
instance of a contract requires multiple NFTs, so it is crucial that
currency creation is as lightweight as possible. In our proposal, each
NFT adds a single pay-to-script transaction output to the initial
transaction of the contract, and does not otherwise put a burden on
core nodes.

\medskip 
Here is an example of a validator script that implements a
non-fungible token using our proposal.  This is expressed as a Haskell
function, and is very similar to the Haskell code that would be used
in in a Plutus contract.

\begin{lstlisting}
data NFT = NFT { nftName :: String, nftBootstrapTxOut :: TxOutput }

 nftValidator :: NFT -> Data -> Redeemer -> PendingTx -> ()
 nftValidator (NFT nm txout) _ _ ptx =
  let con1 = ptx `spends` txout
      con2 = ptx `forges` 1 (ownAddress ptx)
  in if con1 && con2 then () else error
\end{lstlisting}

\noindent The function \verb|spends :: PendingTx -> TxOut -> Bool| checks if the
pending transaction spends the output \verb|txout| (uniquely
identified by transaction hash and the index into its list of
outputs). The function
\verb|forges :: PendingTx -> Int -> ByteString -> Bool|
checks if the
pending transaction forges the given amount of the
address. \verb|Data| and \verb|Redeemer| are the types (in Plutus
Core) of the data and redeemer scripts, which we ignore here (so
effectively both are the unit type \verb|()|). For an actual currency we could use the
data script to keep track of the current supply.

Note that the validator script for a given NFT definition is given by
\verb|nftValidator nft|, so its address is the hash of
\verb|nftValidator nft|.

The key is the \verb|nftBootstrapTxOut| field. The condition
\verb|con1| ensures that there is only a single transaction that can
forge a value of the NFT, because \verb|txout| can only be spent once
thanks to the no-double-spending rule. Condition \verb|con2| ensures
that only a single token of the currency is created, effectively
making it non-fungible.

It is of course possible to produce multiple script outputs to the
same address of \verb|nftValidator nft| but only one of them can be spent,
because the referenced tx output can only be spent once.

Note that creating an NFT with this contract requires three
transactions: One for the nftBootstrapTxOut transaction output, one
for producing an output to the NFT address, and one that forges the
token, consuming the output from the NFT address and the
\verb|nftBootstrapTxOut|. Note that the bootstrap transaction output can be
any unspent transaction output owned by us, in particular it can be
the same output that pays the fees for the forging transaction.

\subsubsection{Another example?}
  
\section{XUTXO-3: Non-fungible tokens}
\label{sec:xutxo-3}

We have shown above how NFTs can be implemented in the XUTXO-2 model,
but this method is arguably a little heavyweight.  In this section we
describe the XUTXO-3 model which provides much more lightweight
support of NFTs.

The basic idea is to change the \valuemap{} type used in XUTXO-2.  The
new definition will allow us to support both fungible and non-fungible
tokens, with no need to change any of the other ledger rules.

The new definition is given in Figure~\ref{fig:xutxo-3-types}:

\begin{ruledfigure}{H}
  \[
  \newvaluemap = \Map{\s{CurrencyId}}{\Map{\s{Token}}{\s{Quantity}}}
  \]
  where
  \begin{itemize}
\item \s{CurrencyId} is the type we are using to identify currencies, as in Figure~\ref{fig:xutxo-2-types}.
\item \s{Token} is a type consisting of identifiers for individual
  tokens.  These will probably be hashes in practice.
\item \s{Quantity} is a type used to measure the amount of a token
  that is present, probably the type of natural numbers.
  \end{itemize}
  \caption{Modified \valuemap{} type for XUTXO-3}
  \label{fig:xutxo-3-types}
\end{ruledfigure}

\noindent Note that the comparison and addition operations for maps defined in
Figure~\ref{fig:basic-notation} carry over to the type \newvaluemap.
This allows us to define XUTXO-3 by exactly the same types and
validity rules as XUTXO-2, simply replacing \valuemap{} by
\newvaluemap{} everywhere.

\subsection{Implications}
This model allows us to implement fungible (normal) and non-fungible
token currencies, as well as ``mixed states'':
\begin{itemize}
\item Fungible token currencies are implemented by only ever issuing
  \s{Quantity}s of a single \s{Token}.
\item Non-fungible token currencies are implemented by only ever
  issuing unit \s{Quantity}s of many unique \s{Token}s.
\item Note that there is nothing in this model which enforces
  uniqueness: having multiples of a single \s{Token} merely means that
  those can be used fungibly. If a currency wants to make sure it only
  issues unique tokens it must track this itself.  These ``mixed'' token
  currencies can have many \s{Token}s, but these can have more than unit
  \s{Quantity}s in circulation.  These can be useful to model distinct
  categories of thing where there are fungible quantities within
  those, for example share classes. \red{Eh?}
\end{itemize}

\paragraph{Performance.}
\red{I'm just making random stuff up here.}
The UTXO-2 and UTXO-3 models will lose some efficiency in comparison
to the UTXO-1 model, simply because the data structures are more
complicated.  This would even apply to transactions which only involve
to native currency, since it would be necessary to check whether the
\valuemap{} contains anything that needs to be processed.  If this is
a concern then one could implement a model with two types of
transaction, essentially just the disjoint union of the XUTXO-1 and
XUTXO-2 or XUTXO-3 transaction types. A simple case distinction at the
start of a transaction could then select either a fast
native-currency-only calculation or a slower multicurrency calculation.
This would be harder to maintain though.

\medskip
A more significant cost may be that we can no longer use \verb|{-# UNPACK #-}|
when our Value type stops being a simple combination of wrappers
and products around primitives, but this is again an issue with any
multi-currency proposal.

  
\subsection{Further generalisations}
We have assumed that our basic \valuetype{} type is the type of
natural numbers.  However, the models mostly carry over to the case
where \valuetype{} is an arbitrary abelian group\footnotemark.  We can
even replace \valuetype{} with a commutative monoid as long as we
relinquish the ability to destroy quantities of currencies (since we
can no longer subtract in general). Whether these generalisations are
useful in practice remains to be seen.

\footnotetext{If we allow a non-abelian group then we may be in
  trouble.  If we forge $a$ units of currency, then forge $b$ units,
  then destroy $a$ units again, we're left with $aba^{-1}$ (or
  $a+b-a$) units, which won't be equal to $b$ in general: if your
  currency consists of elements of the free group on $\{a,b\}$ then
  things could get pretty interesting.  Similar things may happen if
  we need to split up an output to get some change. In the monoid
  case, we might get unexpected cancellation as well: $a+b=0$, but
  $a,b \ne 0$: consider $\mathbb{Z}_{24}$ or something. I suppose
  doing things like this would let us write weird papers to impress
  the cryptocurrency community. It could still be useful for something
  though...}



\section{What else do we need to worry about?}
\begin{itemize}
\item Should we mention the problem of \textbf{validating the next data script}?
%% https://github.com/input-output-hk/plutus/issues/426

\item Sometimes I'm saying ``datascript'' and at other times ``data script''.
  Maybe we should try to be consistent about this.
  
\item Do we need to worry about who signs the various scripts, or is that
  something the wallet deals with?

\item Who's responsible for looking after the scripts, and where are they kept?
  Presumably scripts will be stored in the chain, but how do they get there?

\item Is the number of inputs and/or outputs to a transaction always nonzero?
  Now that we're allowed to destroy currency, maybe we can have transactions
  with no outputs.

\item Do we want to include \s{PayToPubKey} transactions in the
  specification?  We definitely want a special case for this in the
  implementation, but you can do it with the general scripts framework
  anyway. Maybe we should mention that somewhere.

\end{itemize}
  



%% \section{More stuff}

%% When $T$ wants to unlock $O$,
%% the redeemer for the appropriate input of $T$ is applied to three arguments:
%% \begin{itemize}
%% \item A \textit{datascript}, provided by the producer $S$.
%% \item A \textit{validator} script, provided by the producer $S$. 
%% \item A \textit{redeemer} script, provided by the consumer $T$.  
%% \end{itemize}

%% \blue{The GitHub page on Extended UTXO at
%%   https://github.com/input-output-hk/plutus/tree/master/docs/extended-utxo
%%   says ``The validator script must be submitted as part of the
%%   consuming transaction's input, but its content is determined by the
%%   producing transaction.''. I'm finding this difficult to explain.}


%%  When $T$ wants to unlock $O$, the validator for $O$ of $T$ is applied
%%  to three arguments: the redeemer script, the data script, and
%%  information (supplied by the slot leader) about the current
%%  transaction and the state of the blockchain, described by some type
%%  $P$.

%% If the result evaluates to anything other than the Plutus Core
%% \texttt{error} term then validation succeeds and the output is unlocked.

%% Every input of a transaction has an associated redeemer and for the
%% transaction to proceed the redemption of every input must be validated
%% successfully.

%% In the current Plutus implementation, the type $P$ contains the
%% following information:

%% \begin{itemize}
%% \item The validity interval of $T$.
%% \item The hash of $T$.
%% \item For every input of $T$, its value and the hashes of its
%%   validator, data, and redeemer scripts (if the input refers to an output
%%   locked by a script) or the public key and signature (if it refers to
%%   an output locked by a public key)
%% \item For every output of $T$, its value and the hash of its validator
%%   and data script, or the public key that owns it
%% %\item The sum of the values of all unspent outputs (of the current
%%   %blockchain without $T$) which are locked by $O$'s validator script.
%% \end{itemize}

%% The expressivity of contracts depends on the choice of $P$, and $P$
%% may be extended in future to include more information if required.

%% \subsection{Extended UTXO and Standard UTXO}

%% \blue{This is really feeble.}

%% Our extended version of the UTXO model genuinely does offer more than
%% the standard version, as implemented by Bitcoin.

%% %% Duncan: Perhaps one approach to explaining this is to start by
%% %% noting that classically we don't think of data values flowing along
%% %% the edges of the utxo graph, but that this is very useful for
%% %% scripts.

%% \subsubsection{Datascripts}
%% \label{sec:datascripts}
%% Datascripts allow us to separate information about the state
%% of the transaction from the validator script, meaning that we can
%% have situations such as a single validator which refunds outputs
%% to addresses contained in the data script (as in the crowdfunding
%% example).  In the Bitcoin model, each output would require a
%% specialised validator, increasing memory usage.
    
%% \subsubsection{Constraining outputs}
%% \label{sec:constraining-outputs}
%% The fact that the validator receives information about the
%% state of the chain allows us to do things like restricting where
%% the output of a transaction goes, so it's possible to construct
%% graphs of transactions where values are constrained to flow down
%% allowed paths. In the classic model if you can validate at all you
%% can always take the money and keep it.

%% \subsubsection{Deterministic Scripts}
%% \label{sec:deterministic-scripts}
%% When core nodes validate an input spending from a pay-to-script
%% address, they supply two pieces of information to the validator
%% script: The structure of the transaction that is being validated (in
%% form of a list of hashes and signatures), and an indication of the
%% current time (expressed in terms of the slot number: see
%% \ref{subsection:blockchains}).  After a transaction has been submitted
%% to the blockchain, it may linger in the transaction pool for some time
%% before being processed by a core node. Allowing validator scripts to
%% know the exact slot number of their validation would therefore make
%% them non-deterministic, in the sense that their result depends on
%% information that is not known at the time the transaction is
%% submitted.  Non-determinism is a problem because it makes it
%% impossible to accurately compute the gas cost of consuming a
%% pay-to-script output, running counter to our stated goals of
%% measurable and predictable resource consumption.

%% In the Extended UTXO model we add a \emph{validity interval}, an
%% interval of slots, to each transaction's metadata. Core nodes only
%% attempt to validate transactions whose validity interval contains the
%% current slot. When a scripted transaction input is validated, the
%% transaction's validity interval is passed to the validator script,
%% providing information about the current time. Since the validity
%% interval is known at the time the transaction is submitted to the
%% chain, transaction validation in Plutus is completely deterministic.

%% As a result, the exact amount of gas that is required to run the script can be 
%% calculated in advance (by running it), and users do not risk being surprised by 
%% failed validations that still incur fees.    


\bibliographystyle{plain} %% ... or whatever
\bibliography{extended-utxo-specification}


\end{document}
