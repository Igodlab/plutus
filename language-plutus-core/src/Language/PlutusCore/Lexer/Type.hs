{-# LANGUAGE DeriveAnyClass     #-}
{-# LANGUAGE DeriveFunctor      #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE DeriveLift         #-}
{-# LANGUAGE OverloadedStrings  #-}

module Language.PlutusCore.Lexer.Type ( BuiltinName (..)
                                      , Version (..)
                                      , Keyword (..)
                                      , Special (..)
                                      , Token (..)
                                      , TypeBuiltin (..)
                                      , prettyBytes
                                      ) where

import qualified Data.ByteString.Lazy               as BSL
import qualified Data.Text                          as T
import           Data.Text.Encoding                 (decodeUtf8)
import           Data.Text.Prettyprint.Doc.Internal (Doc (Text))
import           Language.PlutusCore.Name
import           Numeric                            (showHex)
import           PlutusPrelude
import           Language.Haskell.TH.Syntax (Lift)

-- | A builtin type
data TypeBuiltin = TyByteString -- FIXME these should take integer/naturals
                 | TyInteger
                 | TySize
                 deriving (Show, Eq, Ord, Generic, NFData, Lift)

-- | Builtin functions
data BuiltinName = AddInteger
                 | SubtractInteger
                 | MultiplyInteger
                 | DivideInteger
                 | RemainderInteger
                 | LessThanInteger
                 | LessThanEqInteger
                 | GreaterThanInteger
                 | GreaterThanEqInteger
                 | EqInteger
                 | ResizeInteger
                 | IntToByteString
                 | Concatenate
                 | TakeByteString
                 | DropByteString
                 | ResizeByteString
                 | SHA2
                 | SHA3
                 | VerifySignature
                 | EqByteString
                 | TxHash
                 | BlockNum
                 | BlockTime
                 deriving (Show, Eq, Ord, Generic, NFData, Lift)

-- | Version of Plutus Core to be used for the program.
data Version a = Version a Natural Natural Natural
               deriving (Show, Eq, Functor, Generic, NFData, Lift)

-- | A keyword in Plutus Core.
data Keyword = KwAbs
             | KwLam
             | KwFix
             | KwFun
             | KwAll
             | KwByteString
             | KwInteger
             | KwSize
             | KwType
             | KwProgram
             | KwCon
             | KwWrap
             | KwUnwrap
             | KwError
             deriving (Show, Eq, Generic, NFData)

-- | A special character. This type is only used internally between the lexer
-- and the parser.
data Special = OpenParen
             | CloseParen
             | OpenBracket
             | CloseBracket
             | Dot
             | Exclamation
             | OpenBrace
             | CloseBrace
             deriving (Show, Eq, Generic, NFData)

-- | A token generated by the lexer.
data Token a = LexName { loc        :: a
                       , name       :: BSL.ByteString
                       , identifier :: Unique -- ^ A 'Unique' assigned to the identifier during lexing.
                       }
             | LexInt { loc :: a, int :: Integer }
             | LexBS { loc :: a, bytestring :: BSL.ByteString }
             | LexBuiltin { loc :: a, builtin :: BuiltinName }
             | LexNat { loc :: a, nat :: Natural }
             | LexKeyword { loc :: a, keyword :: Keyword }
             | LexSpecial { loc :: a, special :: Special }
             | EOF { loc :: a }
             deriving (Show, Eq, Generic, NFData)

asBytes :: Word8 -> Doc a
asBytes = Text 2 . T.pack . ($ mempty) . showHex

prettyBytes :: BSL.ByteString -> Doc a
prettyBytes b = "#" <> fold (asBytes <$> BSL.unpack b)

instance PrettyA Special where
    prettyA OpenParen    = "("
    prettyA CloseParen   = ")"
    prettyA OpenBracket  = "["
    prettyA CloseBracket = "]"
    prettyA Dot          = "."
    prettyA Exclamation  = "!"
    prettyA OpenBrace    = "{"
    prettyA CloseBrace   = "}"

instance PrettyA Keyword where
    prettyA KwAbs        = "abs"
    prettyA KwLam        = "lam"
    prettyA KwFix        = "fix"
    prettyA KwFun        = "fun"
    prettyA KwAll        = "forall"
    prettyA KwByteString = "bytestring"
    prettyA KwInteger    = "integer"
    prettyA KwSize       = "size"
    prettyA KwType       = "type"
    prettyA KwProgram    = "program"
    prettyA KwCon        = "con"
    prettyA KwWrap       = "wrap"
    prettyA KwUnwrap     = "unwrap"
    prettyA KwError      = "error"

instance PrettyA (Token a) where
    prettyA (LexName _ n _)   = pretty (decodeUtf8 (BSL.toStrict n))
    prettyA (LexInt _ i)      = pretty i
    prettyA (LexNat _ n)      = pretty n
    prettyA (LexBS _ bs)      = prettyBytes bs
    prettyA (LexBuiltin _ bn) = prettyA bn
    prettyA (LexKeyword _ kw) = prettyA kw
    prettyA (LexSpecial _ s)  = prettyA s
    prettyA EOF{}             = mempty

instance PrettyA BuiltinName where
    prettyA AddInteger           = "addInteger"
    prettyA SubtractInteger      = "subtractInteger"
    prettyA MultiplyInteger      = "multiplyInteger"
    prettyA DivideInteger        = "divideInteger"
    prettyA RemainderInteger     = "remainderInteger"
    prettyA LessThanInteger      = "lessThanInteger"
    prettyA LessThanEqInteger    = "lessThanEqualsInteger"
    prettyA GreaterThanInteger   = "greaterThanInteger"
    prettyA GreaterThanEqInteger = "greaterThanEqualsInteger"
    prettyA EqInteger            = "equalsInteger"
    prettyA ResizeInteger        = "resizeInteger"
    prettyA IntToByteString      = "intToByteString"
    prettyA Concatenate          = "concatenate"
    prettyA TakeByteString       = "takeByteString"
    prettyA DropByteString       = "dropByteString"
    prettyA ResizeByteString     = "resizeByteString"
    prettyA EqByteString         = "equalsByteString"
    prettyA SHA2                 = "sha2_256"
    prettyA SHA3                 = "sha3_256"
    prettyA VerifySignature      = "verifySignature"
    prettyA TxHash               = "txhash"
    prettyA BlockNum             = "blocknum"
    prettyA BlockTime            = "blocktime"

instance PrettyA TypeBuiltin where
    prettyA TyInteger    = "integer"
    prettyA TyByteString = "bytestring"
    prettyA TySize       = "size"

instance PrettyA (Version a) where
    prettyA (Version _ i j k) = pretty i <> "." <> pretty j <> "." <> pretty k
